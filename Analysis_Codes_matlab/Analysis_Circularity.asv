clear; clc; close all;


%%
para1 = readtable("../para1_in.dat");
dt = table2array(para1(8,1));
nrun = 2;

time = 0;
ct = 1;
for it = 1000:1000:10000000
    ct

    [Lx, Ly, v, inn, num, ~, biochemdata] = LoadData(it, nrun);

    [borderver, borderdim] = FindBorderVertices(Lx, Ly, inn, num);
    vx = v(borderver,1);
    vy = v(borderver,2);
    [circularity(ct), hullXH, hullYH] = calculateCircularityWithQhull(vx, vy);
    time(ct) = it*dt;
    ct = ct + 1;

    clear v inn num
end

scatter(hullX, hullY)


%writematrix([time' circularity'],"circularity_Active_Contractility.dat");
% Full path of the current file
filePath = matlab.desktop.editor.getActiveFilename;

% Directory containing the file
scriptDir = fileparts(filePath);

% Parent directory
parentDir = fileparts(scriptDir);

% Extract folder name safely (no dot issues)
parts = split(parentDir, filesep);
parentName = parts{end};

% Construct filename
fname = sprintf('Q-time_%s.dat', parentName)

% Write file
writematrix([time' Qt'], fullfile(scriptDir, fname));




%%

figure("Position",[100 100 800 800])

plot(time, circularity,'o', "LineWidth",3, 'MarkerSize',20);
hold on; 


xlabel("Time");
ylabel("Circularity")
set(gca, "FontSize", 32)
axis square
legend()





%%
function [borderver, borderdim] = FindBorderVertices(Lx, Ly, inn, num)
% Initialize variables
borderdim = 0;
bordercount = zeros(1, max(inn(:))); % Assuming inn contains vertex indices

% Calculate border count
for ic = 1:Lx*Ly
    nn = num(ic);
    for jc = 1:nn
        bordercount(inn(ic, jc)) = bordercount(inn(ic, jc)) + 1;
    end
end



% Calculate border vertices and dimension
borderver = zeros(1, numel(bordercount));
for ip = 1:numel(bordercount)
    if bordercount(ip) < 3 && bordercount(ip) > 1
        borderdim = borderdim + 1;
        borderver(borderdim) = ip;
    end
end

% Trim excess zeros from borderver
borderver = borderver(1:borderdim);
end

function [circularity, hullX, hullY] = calculateCircularityWithQhull(x, y)
% Compute convex hull using Qhull
K = convhull(x, y);
hullX = x(K);
hullY = y(K);


% Calculate area using polyarea
area = polyarea(hullX, hullY);

% Calculate perimeter using the distance between consecutive hull points
perimeter = 0;
n = length(hullX);
for i = 1:n-1
    dx = hullX(i+1) - hullX(i);
    dy = hullY(i+1) - hullY(i);
    perimeter = perimeter + sqrt(dx^2 + dy^2);
end
% Add distance between last and first point to complete the loop
dx = hullX(1) - hullX(n);
dy = hullY(1) - hullY(n);
perimeter = perimeter + sqrt(dx^2 + dy^2);

% Calculate circularity
circularity = (4 * pi * area) / (perimeter^2);
end
